#pragma once
#include "rng.hpp"

constexpr tr::Xorshiftr128p::Xorshiftr128p(std::uint64_t seed) noexcept
	: _state{seed++ >> 32, seed << 32}
{
}

constexpr std::uint64_t tr::Xorshiftr128p::advance() noexcept
{
	uint64_t x = _state[0];
	uint64_t y = _state[1];
	_state[0]  = y;
	x ^= x << 23;
	x ^= x >> 17;
	x ^= y;
	_state[1] = x + y;
	return x;
}

constexpr bool tr::randb(Xorshiftr128p& rng) noexcept
{
	// Upper bits of the value generated by advance() have better randomness.
	return rng.advance() >> 63;
}

template <std::integral T> constexpr T tr::rand(Xorshiftr128p& rng) noexcept
{
	// Upper bits of the value generated by advance() have better randomness.
	return static_cast<T>(rng.advance() >> ((sizeof(rng.advance()) - sizeof(T)) * 4));
}

template <std::integral T> constexpr T tr::rand(Xorshiftr128p& rng, T max) noexcept
{
	assert(max != 0);

	return static_cast<T>(rand<T>(rng) % max);
}

template <std::integral T> constexpr T tr::rand(Xorshiftr128p& rng, T min, T max) noexcept
{
	assert(min < max);

	return static_cast<T>(rand<T>(rng) % (max - min) + min);
}

template <std::floating_point T> constexpr T tr::rand(Xorshiftr128p& rng) noexcept
{
	return static_cast<T>(rng.advance()) / static_cast<T>(std::numeric_limits<std::uint64_t>::max());
}

template <std::floating_point T> constexpr T tr::rand(Xorshiftr128p& rng, T max) noexcept
{
	return rand<T>(rng) * max;
}

template <std::floating_point T> constexpr T tr::rand(Xorshiftr128p& rng, T min, T max) noexcept
{
	assert(min < max);

	return rand<T>(rng) * (max - min) + min;
}

template <tr::SpecializationOf<tr::Angle> T> constexpr T tr::rand(Xorshiftr128p& rng) noexcept
{
	return tr::turns(rand<decltype(T{}.turns())>(rng));
}

template <tr::SpecializationOf<tr::Angle> T> constexpr T tr::rand(Xorshiftr128p& rng, T max) noexcept
{
	return rand<T>(rng) * max.turns();
}

template <tr::SpecializationOf<tr::Angle> T> constexpr T tr::rand(Xorshiftr128p& rng, T min, T max) noexcept
{
	assert(min < max);

	return rand<T>(rng) * (max - min).turns() + min;
}